# 3 章 レスポンスデータの設計

## 3.1 データフォーマット

- JSON にデフォルトとして対応し、需要や必要性に応じて XML 等に対応する
- データフォーマットの指定方法の実装
	1. クエリパラメータ (`https://api.example.com/v1/users?format=xml`)
	2. 拡張子 (`https://api.example.com/v1/users.json`)
	3. リクエストヘッダのメディアタイプを指定 (`Accept: application/json`)
- 基本的にはクエリパラメータで実装する

## 3.2 JSONP の取り扱い

### JSONP (JSON with padding)

クロスサイト環境でほかのオリジンから JSON データを取得するために考案された仕組み。XHTTPRequest は同一生成元ポリシーの制限によって、同じドメインへのアクセスしか行うことができない。  
script タグでは src 属性に他ドメインを指定できることを利用する。

1. ドメイン A でコールバック関数を用意
2. script タグを生成しドメイン B にアクセス。この時 url パラメータでコールバック関数の名称を伝える。(`<script src="http://domain_b/?callback=callback"></script>`)
3. ドメイン B ではデータ取得等を行い、データを引数としたコールバック関数を返却する。(`callback({"id": 123, "name": "saeed"})`)
4. ドメイン A は B から返却されたコールバック関数を実行する

コールバック関数の名前はクエリパラメータ (callback) で指定できるようにするのが一般的。  
コールバック関数を動的に生成する場合等に、別々のコールバック関数を用意することができるようになるため。

callback パラメータが指定されている場合に JSONP を要求していると判断する。

script 要素はエラーステータスコード (400 等) が返るとスクリプトの読み込みを停止するため、JSONP に対応した場合にエラーコードを返すようにするとクライアント側ではそのエラーを検知できない。  
=> エラーが発生しても 200 を返す。レスポンスボディ内にエラー情報を入れ込む。

## 3.3 データの内部構造の考え方

まず考えるべきは、API のアクセス回数がなるべく減るようにすること。ユースケースを考える必要がある。  
(ユーザー一覧の結果で ID だけ返す => 利用する側はユーザー情報も欲しいはず => 一緒にユーザー情報も返したほうが利用しやすい)

### 3.3.1 レスポンスの内容をユーザーが選べるようにする

多数の外部ユーザーが利用するような API はすべてユースケースを想定することはできない。  
シンプルな解決法はできる限り多くのデータを返す。  
ただこの方法ではデータ量が必要以上に大きくなりすぎる。  
⇒ **クエリパラメータで取得したい項目をユーザー側が自由に選択できるようにする**  
(`http://api.example.com/v1/users/123?fields=name,age`)

### 3.3.2 エンベロープは必要か

#### エンベロープ

```
{
	"header": {
		"status": "success",
		"errorCode": 0,
	},
	"response": {
		...実際のデータ...
	}
}
```

上記のように返却するデータに共通したメタデータを含んだ構造のことを**エンベロープ**と呼ぶ。

冗長な表現のため基本期には**やるべきではない**。  
HTTP のレスポンスヘッダで同様のことができる。むしろ HTTP の知識さえあればメタ情報やエラー情報の意味を理解しやすいため、ユーザーフレンドリーになる。  
ただし**JSONP**では利用したほうが便利になる。

### 3.3.3 データはフラットにすべきか

返却するデータを階層的に表すか、フラットに形で表すかは状況次第。

```
階層
{
	"id": 123,
	"sender": {
		"id": 456,
		"name": "Taro Ymamoto"
	},
	"receiver": {
		"id": 789,
		"name": "Kenji Kato"
	}
}

フラット
{
	"id": 123,
	"sender_id": 456,
	"sender_name": "Taro Yamamot",
	"receiver_id": 789,
	"receiver_name": "Kenji Kato"
}
```

上記の例では `sender` と `receiver` は同じユーザーという構造を表すため階層構造で表現したほうが、利用者側はユーザー型として扱いやすくなる。

```
{
	"id": 123,
	"name": "Tanaka Taro",
	"profile": {
		"birthday": "193848754",
		"gender": "male",
		"languages": ["ja", "en"]
	}
}
```

上記の `profile` 項目のように単にまとめるだけの階層構造はあまり意味がない。フラットに表現したほうがデータサイズが小さくなる。また `profile` 単体で処理を行うことは考えにくいため、前出のユーザーの場合のように利用者側の利便性もよくならない。

### 3.3.4 配列とフォーマット

```
{
	"friends": [
		{
			"id": 123,
			...
		},
		{
			"id": 345,
			...
		}
	]
}
```

友人一覧等の配列で値を返す場合、以下の理由からそのまま配列を返すよりもレスポンス全体をオブジェクトにして返すほうが良い。

- レスポンスデータが何を指しているかわかりやすい
- レスポンスデータをオブジェクトに統一できる (クライアント側で共通の前処理が容易になる)
- **セキュリティ上のリスクを避けることができる**

トップレベルが配列である JSON は「[[JSONインジェクション]]」という脆弱性に対するリスクがあるため、基本的には API のレスポンスとして**オブジェクトを返す**ようにするべき。

### 3.3.5 配列の件数、あるいは続きがあるかをどう返すべきか

全体の件数を把握したうえで現在取得済の件数を考えれば続きがあるかはわかる。  
ただし、全体の件数を取得する処理はコストが大きいことが多いので、実際に取得するどうかはユースケースを考える必要がある。  
全体の件数が必要ないなら、サーバー側では取得件数 +1 件の取得を試みて、実際に取得件数 +1 件取得できれば、続きがあるとして考えることができる。

続きがあることの返し方は 2 つ

- 「hasNext」といった名前で結果に含める
- 次のデータ取得に必要な「パラメータ」や「URL」を結果に含める

## 3.4 各データのフォーマット

### 3.4.1 各データの名前

データ項目の名前についての考え方

- 多くの API で同じ意味に利用されている一般的な単語を用いる
- なるべく少ない単語数で表現する  
  （エンドポイント名が/users なら userId ではなく id で良いなど、エンドポイント名も考慮に入れる必要あり）
- 複数の単語を連結する場合、連結方法は API 全体を通して統一する
- 省略系は極力利用しない
- 単数形/複数形に気を付ける  
  （この項目で返る値が複数になる可能性があるのか、１つのみなのか）

### 3.4.2 性別のデータをどう表すか

項目名によって変わる。

#### sex (生物学的な性別)

生物学的な性別はその他 (不明等) を含めても 3 種類  
⇒文字列 (male, female 等) や数字 (1: male, 2: female)

#### gender (社会的・文化的性別)

社会的に認められつつある性別 (Cis Woman, Trans 等) も含まれるため数が多い。  
また今後増減する可能性がある。  
⇒基本的に文字列で表す

どちらの項目名を使うかは、サービスが生物学的な性別が必要な場合は sex、そうでない場合は gender を利用する。  
API 全体で統一すべき。

### 3.4.3 日付のフォーマット

フォーマット例  

| 形式名                         | 例                             |
| ------------------------------ | ------------------------------ |
| RFC 822                        | Sun, 06 Nov 1994 08:49:37 GMT  |
| RFC 850                        | Sunday, 06-Nov-94 08:49:37 GMT |
| ANSI C の astime() 形式        | Sun Nov 6 08:49:37 1994        |
| RFC 3339                       | 2015-10-12T11:30:22+09:00      |
| Unix タイムスタンプ (epoch 秒) | 1396821893                     |

広く一般に公開され、どのようなユーザーが利用するのか予測が難しい API(LSUDs をターゲットとした API) では**RFC 3339**を利用するのがよい。

タイムゾーンは**UTC(協定世界時, +00:00)** を利用するのがよい。

自社アプリ等で SSKDs 対象の場合は Unix タイムスタンプも候補に挙がる。

### 3.4.4 大きな整数と JSON

大きな数字は処理するシステムや言語によってはトラブルになることがある。  
例として JavaScript では数値をすべて 64 ビット浮動小数として扱うため、下記を実行すると 462781738297483260 となり誤差が生じる。

```javascript
var data = JSON.parse('{"id": 462781738297483264}');
console.log(data.id); // 462781738297483260
```

このような問題を回避するためには、ID などで巨大な数値を扱う場合は数値をそのままかえすのではなく、**文字列として返す**と回避することができる。(Twitter API では数値とともに文字列を格納して返している)

## 3.5 レスポンスデータの設計

- API は内部で持っている DB 等のデータ構造をそのまま反映する必要はない
- ユーザー情報を一つのオブジェクトとして定義すると、API 通して共通して利用することで、ユーザー側は同じロジックで処理ができる
- クライアント側の利用しやすい形に、かつシンプルにする
- 結局、API のユースケースを考えて設計する必要がある

## 3.6 エラーの表現

クライアント側がエラーの原因の調査・特定に役立つ情報をなるべく多く返す必要がある。

### 3.6.1 ステータスコードでエラーを表現する

| ステータスコード | 意味                               |
| ---------------- | ---------------------------------- |
| 100 番台          | 情報                               |
| 200 番台          | 成功                               |
| 300 番台          | リダイレクト                       |
| 400 番台          | クライアントサイドに起因するエラー |
| 500 番台          | サーバーサイドに起因するエラー     |

データとしてエラー情報を返すが、HTTP レスポンスのステータスコードとして 200 番台を返すようなことはしてはならない。  
適切なステータスコードで返すことで、クライアント側の原因特定につながる。  
ピッタリくるステータスコードが存在しない場合は、"200", "400" 等の 00 番を利用する。

### 3.6.2 エラーの詳細をクライアントに返す

ステータスコードは汎用的な意味を表す。→エラーの詳細情報も返す必要がある。  
エラーの内容を返す方法は大きく 2 つ。

- レスポンスヘッダに入れる  
  ("X-MYNAME-ERROR-MESSAGE: Bad authentication token" のように独自のヘッダ項目を利用する)
- レスポンスボディに入れる

ほとんどの API はレスポンスボディにエラー情報を入れて返している。  
→クライアント側の利便性がよいためか

### 3.6.3 エラー詳細情報には何を入れるべきか

返す内容は以下の通り。

- エラーの詳細コード
- エラーメッセージ (人間が読める形式)
- さらなる情報が記載されたドキュメントページの URI

エラーの詳細情報は API ごとに決める。既存のステータスコードと区別できるようにする。4 桁数字でステータスコードと同様に番台でカテゴリ分けするとよい。

エラーメッセージエンドユーザーに直接表示できるような「非開発者向けメッセージ」と開発者が原因特定に利用できるような「開発者向けメッセージ」を両方含める方法もある。

### 3.6.4 エラーの際に HTML が返ることを防ぐ

基本的に API の結果は JSON や XML で返ることを期待される。  
nginx 等のサーバーやアプリケーションフレームワークでデフォルトで 404 エラー等が HTML で返ることになっていることが多い。  
エラー発生時でも適切なフォーマットでデータが返るようにする。

### 3.6.5 メンテナンスとステータスコード

API を停止しなければならない自体は極力避けるべき。API を利用しているサービスが動作しない、または一部動作が制限されるため。

メンテナンスで停止する場合は 503（HTTP 503 Service Unavailable）を返す。  
予定されたメンテナンスで終了予定時刻が分かっている場合はそれも通知するべき。  
**Retry-After**という HTTP ヘッダにいつメンテナンスが終わるかを具体的な日付や、現在時刻からアクセス可能になるまでの秒数を入れる。

```
503 Service Temporary Unavailable
Retry-After: Mon, 2 Dec 2013 03:00:00 GMT
```

### 3.6.6 意図的に不正確な情報を返したい場合

セキュリティ上やその他の理由で情報を曖昧にしたいケースが存在する。

ブロック機能がある場合に、ブロックされたユーザーがブロックしたユーザー情報を取得しようとした場合等。エラーで返すが、メッセージでブロックされていると伝えるとさらなるトラブルにつながる可能性がある。  
→「ブロックされた側からみるとブロックした側はすでに存在しないと同義」として 404 を返すことも可能。

ログイン時に「メールアドレスが存在しない」「パスワードが違う」等の原因を伝えるのは悪意を持ったユーザーに対しても情報を与えることになる。

正確な情報を返すのはあくまでも**開発の効率化やユーザー体験の向上のため**。  
正確な情報を返すことでそれらが阻害されるならば返すべきではない。

# 4 章 HTTP の仕様を最大限利用する

## 4.1 HTTP の仕様を利用する意義

標準の仕様をできる限り利用した API は第 3 者にとっても理解しやすい。  
利用時のバグ混入を減らしたり、再利用可能性が高くなる。

## 4.2 ステータスコードを正しく使う

ステータスコードは HTTP のレスポンスヘッダの先頭に必ず入っている 3 桁の数字。リクエストがサーバによって処理された際のステータスを表す。

汎用的な HTTP のクライアントライブラリは基本的にステータスコードをみて振る舞いを決めるため、適切なステータスコードを返さないと余計な問題を引き起こすことになる。

### 4.2.1 200 番台: 成功
