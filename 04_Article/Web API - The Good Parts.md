# 3 章 レスポンスデータの設計

## 3.1 データフォーマット

- JSON にデフォルトとして対応し、需要や必要性に応じて XML 等に対応する
- データフォーマットの指定方法の実装
	1. クエリパラメータ (`https://api.example.com/v1/users?format=xml`)
	2. 拡張子 (`https://api.example.com/v1/users.json`)
	3. リクエストヘッダのメディアタイプを指定 (`Accept: application/json`)
- 基本的にはクエリパラメータで実装する

## 3.2 JSONP の取り扱い

### JSONP (JSON with padding)

クロスサイト環境でほかのオリジンから JSON データを取得するために考案された仕組み。XHTTPRequest は同一生成元ポリシーの制限によって、同じドメインへのアクセスしか行うことができない。  
script タグでは src 属性に他ドメインを指定できることを利用する。

1. ドメイン A でコールバック関数を用意
2. script タグを生成しドメイン B にアクセス。この時 url パラメータでコールバック関数の名称を伝える。(`<script src="http://domain_b/?callback=callback"></script>`)
3. ドメイン B ではデータ取得等を行い、データを引数としたコールバック関数を返却する。(`callback({"id": 123, "name": "saeed"})`)
4. ドメイン A は B から返却されたコールバック関数を実行する

コールバック関数の名前はクエリパラメータ (callback) で指定できるようにするのが一般的。  
コールバック関数を動的に生成する場合等に、別々のコールバック関数を用意することができるようになるため。

callback パラメータが指定されている場合に JSONP を要求していると判断する。

script 要素はエラーステータスコード (400 等) が返るとスクリプトの読み込みを停止するため、JSONP に対応した場合にエラーコードを返すようにするとクライアント側ではそのエラーを検知できない。  
=> エラーが発生しても 200 を返す。レスポンスボディ内にエラー情報を入れ込む。

## 3.3 データの内部構造の考え方

まず考えるべきは、API のアクセス回数がなるべく減るようにすること。ユースケースを考える必要がある。  
(ユーザー一覧の結果で ID だけ返す => 利用する側はユーザー情報も欲しいはず => 一緒にユーザー情報も返したほうが利用しやすい)

### 3.3.1 レスポンスの内容をユーザーが選べるようにする

多数の外部ユーザーが利用するような API はすべてユースケースを想定することはできない。  
シンプルな解決法はできる限り多くのデータを返す。  
ただこの方法ではデータ量が必要以上に大きくなりすぎる。  
⇒ **クエリパラメータで取得したい項目をユーザー側が自由に選択できるようにする**  
(`http://api.example.com/v1/users/123?fields=name,age`)

### 3.3.2 エンベロープは必要か

#### エンベロープ

```
{
	"header": {
		"status": "success",
		"errorCode": 0,
	},
	"response": {
		...実際のデータ...
	}
}
```

上記のように返却するデータに共通したメタデータを含んだ構造のことを**エンベロープ**と呼ぶ。

冗長な表現のため基本期には**やるべきではない**。  
HTTP のレスポンスヘッダで同様のことができる。むしろ HTTP の知識さえあればメタ情報やエラー情報の意味を理解しやすいため、ユーザーフレンドリーになる。  
ただし**JSONP**では利用したほうが便利になる。

### 3.3.3 データはフラットにすべきか

返却するデータを階層的に表すか、フラットに形で表すかは状況次第。

```
階層
{
	"id": 123,
	"sender": {
		"id": 456,
		"name": "Taro Ymamoto"
	},
	"receiver": {
		"id": 789,
		"name": "Kenji Kato"
	}
}

フラット
{
	"id": 123,
	"sender_id": 456,
	"sender_name": "Taro Yamamot",
	"receiver_id": 789,
	"receiver_name": "Kenji Kato"
}
```

上記の例では `sender` と `receiver` は同じユーザーという構造を表すため階層構造で表現したほうが、利用者側はユーザー型として扱いやすくなる。

```
{
	"id": 123,
	"name": "Tanaka Taro",
	"profile": {
		"birthday": "193848754",
		"gender": "male",
		"languages": ["ja", "en"]
	}
}
```

上記の `profile` 項目のように単にまとめるだけの階層構造はあまり意味がない。フラットに表現したほうがデータサイズが小さくなる。また `profile` 単体で処理を行うことは考えにくいため、前出のユーザーの場合のように利用者側の利便性もよくならない。

### 3.3.4 配列とフォーマット
