# 3 章 レスポンスデータの設計

## 3.1 データフォーマット

- JSON にデフォルトとして対応し、需要や必要性に応じて XML 等に対応する
- データフォーマットの指定方法の実装
	1. クエリパラメータ (`https://api.example.com/v1/users?format=xml`)
	2. 拡張子 (`https://api.example.com/v1/users.json`)
	3. リクエストヘッダのメディアタイプを指定 (`Accept: application/json`)
- 基本的にはクエリパラメータで実装する

## 3.2 JSONP の取り扱い

### JSONP (JSON with padding)

クロスサイト環境でほかのオリジンから JSON データを取得するために考案された仕組み。XHTTPRequest は同一生成元ポリシーの制限によって、同じドメインへのアクセスしか行うことができない。  
script タグでは src 属性に他ドメインを指定できることを利用する。

1. ドメイン A でコールバック関数を用意
2. script タグを生成しドメイン B にアクセス。この時 url パラメータでコールバック関数の名称を伝える。(`<script src="http://domain_b/?callback=callback"></script>`)
3. ドメイン B ではデータ取得等を行い、データを引数としたコールバック関数を返却する。(`callback({"id": 123, "name": "saeed"})`)
4. ドメイン A は B から返却されたコールバック関数を実行する

コールバック関数の名前はクエリパラメータ (callback) で指定できるようにするのが一般的。  
コールバック関数を動的に生成する場合等に、別々のコールバック関数を用意することができるようになるため。

callback パラメータが指定されている場合に JSONP を要求していると判断する。

script 要素はエラーステータスコード (400 等) が返るとスクリプトの読み込みを停止するため、JSONP に対応した場合にエラーコードを返すようにするとクライアント側ではそのエラーを検知できない。  
=> エラーが発生しても 200 を返す。レスポンスボディ内にエラー情報を入れ込む。

## 3.3 データの内部構造の考え方

まず考えるべきは、API のアクセス回数がなるべく減るようにすること。ユースケースを考える必要がある。  
(ユーザー一覧の結果で ID だけ返す => 利用する側はユーザー情報も欲しいはず => 一緒にユーザー情報も返したほうが利用しやすい)

### 3.3.1 レスポンスの内容をユーザーが選べるようにする

多数の外部ユーザーが利用するような API はすべてユースケースを想定することはできない。  
シンプルな解決法はできる限り多くのデータを返す。  
ただこの方法ではデータ量が必要以上に大きくなりすぎる。  
⇒ **クエリパラメータで取得したい項目をユーザー側が自由に選択できるようにする**  
(`http://api.example.com/v1/users/123?fields=name,age`)

### 3.3.2 エンベロープは必要か

#### エンベロープ

```
{
	"header": {
		"status": "success",
		"errorCode": 0,
	},
	"response": {
		...実際のデータ...
	}
}
```

上記のように返却するデータに共通したメタデータを含んだ構造のことを**エンベロープ**と呼ぶ。

冗長な表現のため基本期には**やるべきではない**。  
HTTP のレスポンスヘッダで同様のことができる。むしろ HTTP の知識さえあればメタ情報やエラー情報の意味を理解しやすいため、ユーザーフレンドリーになる。  
ただし**JSONP**では利用したほうが便利になる。

### 3.3.3 データはフラットにすべきか

返却するデータを階層的に表すか、フラットに形で表すかは状況次第。

```
階層
{
	"id": 123,
	"sender": {
		"id": 456,
		"name": "Taro Ymamoto"
	},
	"receiver": {
		"id": 789,
		"name": "Kenji Kato"
	}
}

フラット
{
	"id": 123,
	"sender_id": 456,
	"sender_name": "Taro Yamamot",
	"receiver_id": 789,
	"receiver_name": "Kenji Kato"
}
```

上記の例では `sender` と `receiver` は同じユーザーという構造を表すため階層構造で表現したほうが、利用者側はユーザー型として扱いやすくなる。

```
{
	"id": 123,
	"name": "Tanaka Taro",
	"profile": {
		"birthday": "193848754",
		"gender": "male",
		"languages": ["ja", "en"]
	}
}
```

上記の `profile` 項目のように単にまとめるだけの階層構造はあまり意味がない。フラットに表現したほうがデータサイズが小さくなる。また `profile` 単体で処理を行うことは考えにくいため、前出のユーザーの場合のように利用者側の利便性もよくならない。

### 3.3.4 配列とフォーマット

```
{
	"friends": [
		{
			"id": 123,
			...
		},
		{
			"id": 345,
			...
		}
	]
}
```

友人一覧等の配列で値を返す場合、以下の理由からそのまま配列を返すよりもレスポンス全体をオブジェクトにして返すほうが良い。

- レスポンスデータが何を指しているかわかりやすい
- レスポンスデータをオブジェクトに統一できる (クライアント側で共通の前処理が容易になる)
- **セキュリティ上のリスクを避けることができる**

トップレベルが配列である JSON は「[[JSONインジェクション]]」という脆弱性に対するリスクがあるため、基本的には API のレスポンスとして**オブジェクトを返す**ようにするべき。

### 3.3.5 配列の件数、あるいは続きがあるかをどう返すべきか

全体の件数を把握したうえで現在取得済の件数を考えれば続きがあるかはわかる。  
ただし、全体の件数を取得する処理はコストが大きいことが多いので、実際に取得するどうかはユースケースを考える必要がある。  
全体の件数が必要ないなら、サーバー側では取得件数 +1 件の取得を試みて、実際に取得件数 +1 件取得できれば、続きがあるとして考えることができる。

続きがあることの返し方は 2 つ

- 「hasNext」といった名前で結果に含める
- 次のデータ取得に必要な「パラメータ」や「URL」を結果に含める

## 3.4 各データのフォーマット

### 3.4.1 各データの名前

データ項目の名前についての考え方

- 多くの API で同じ意味に利用されている一般的な単語を用いる
- なるべく少ない単語数で表現する  
  （エンドポイント名が/users なら userId ではなく id で良いなど、エンドポイント名も考慮に入れる必要あり）
- 複数の単語を連結する場合、連結方法は API 全体を通して統一する
- 省略系は極力利用しない
- 単数形/複数形に気を付ける  
  （この項目で返る値が複数になる可能性があるのか、１つのみなのか）

### 3.4.2 性別のデータをどう表すか

項目名によって変わる。

#### sex (生物学的な性別)

生物学的な性別はその他 (不明等) を含めても 3 種類  
⇒文字列 (male, female 等) や数字 (1: male, 2: female)

#### gender (社会的・文化的性別)

社会的に認められつつある性別 (Cis Woman, Trans 等) も含まれるため数が多い。  
また今後増減する可能性がある。  
⇒基本的に文字列で表す

どちらの項目名を使うかは、サービスが生物学的な性別が必要な場合は sex、そうでない場合は gender を利用する。  
API 全体で統一すべき。

### 3.4.3 日付のフォーマット

フォーマット例  

| 形式名                         | 例                             |
| ------------------------------ | ------------------------------ |
| RFC 822                        | Sun, 06 Nov 1994 08:49:37 GMT  |
| RFC 850                        | Sunday, 06-Nov-94 08:49:37 GMT |
| ANSI C の astime() 形式        | Sun Nov 6 08:49:37 1994        |
| RFC 3339                       | 2015-10-12T11:30:22+09:00      |
| Unix タイムスタンプ (epoch 秒) | 1396821893                     |

広く一般に公開され、どのようなユーザーが利用するのか予測が難しい API(LSUDs をターゲットとした API) では**RFC 3339**を利用するのがよい。

タイムゾーンは**UTC(協定世界時, +00:00)** を利用するのがよい。

自社アプリ等で SSKDs 対象の場合は Unix タイムスタンプも候補に挙がる。

### 3.4.4 大きな整数と JSON

大きな数字は処理するシステムや言語によってはトラブルになることがある。  
例として JavaScript では数値をすべて 64 ビット浮動小数として扱うため、下記を実行すると 462781738297483260 となり誤差が生じる。

```javascript
var data = JSON.parse('{"id": 462781738297483264}');
console.log(data.id); // 462781738297483260
```

このような問題を回避するためには、ID などで巨大な数値を扱う場合は数値をそのままかえすのではなく、**文字列として返す**と回避することができる。(Twitter API では数値とともに文字列を格納して返している)

## 3.5 レスポンスデータの設計
